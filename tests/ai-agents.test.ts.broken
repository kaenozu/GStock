import { describe, it, expect, beforeEach, vi } from 'vitest';
import { ChairmanAgent, TrendAgent, ReversalAgent, VolatilityAgent } from '@/lib/agents';
import { calculateAdvancedPredictions } from '@/lib/api/prediction-engine';
import { StockDataPoint } from '@/types/market';

// テストデータ生成
const generateTestMarketData = (symbol: string, days: number): StockDataPoint[] => {
  const data: StockDataPoint[] = [];
  const basePrice = 100 + Math.random() * 50;
  
  for (let i = 0; i < days; i++) {
    const date = new Date();
    date.setDate(date.getDate() - i);
    
    const price = basePrice + (Math.random() - 0.5) * 20;
    const volatility = 0.02 + Math.random() * 0.03;
    
    data.push({
      time: date.toISOString().split('T')[0],
      open: price * (1 - volatility),
      high: price * (1 + volatility * 2),
      low: price * (1 - volatility * 2),
      close: price
    });
  }
  
  return data.reverse(); // 古い順にする
};

// エージェントの性能評価
interface AgentPerformance {
  agent: string;
  accuracy: number;
  precision: number;
  recall: number;
  f1Score: number;
  confusionMatrix: number[][];
}

describe('AIエージェント最適化', () => {
  let agents: AgentPerformance[] = [];
  
  beforeEach(() => {
    vi.clearAllMocks();
  });

  describe('既存エージェントの分析', () => {
    // テストデータ生成
    const testMarketData = generateTestMarketData('AAPL', 252); // 2年分のデータ
    
    // 各エージェントの予測精度評価
    const agents = ['ChairmanAgent', 'TrendAgent', 'ReversalAgent', 'VolatilityAgent'];
    
    for (const agentName of agents) {
      const agent = getAgentInstance(agentName);
      
      // 過去1年分のデータで学習
      const trainingData = testMarketData.slice(0, 252);
      agent.train(trainingData);
      
      // 残り1年分のデータでテスト
      const testData = testMarketData.slice(252);
      const predictions = testData.map(data => agent.analyze(data, 'BULL_TREND'));
      
      // 精度計算
      let correctPredictions = 0;
      let totalPredictions = 0;
      const confusionMatrix = Array(4).fill(0).map(() => Array(4).fill(0));
      
      predictions.forEach((pred, i) => {
        const actual = testData[i];
        const actualSignal = actual.close > actual.open ? 'BULLISH' : 'BEARISH';
        
        if (pred.signal === actualSignal) {
          correctPredictions++;
        }
        totalPredictions++;
        
        // 混同行列マトリクス更新
        const actualIndex = actualSignal === 'BULLISH' ? 0 : 1;
        const predIndex = pred.signal === 'BULLISH' ? 0 : 1;
        confusionMatrix[actualIndex][predIndex]++;
      });
      
      // F1スコア計算
      const precision = correctPredictions / totalPredictions;
      const recall = correctPredictions / (predictions.filter(p => p.signal === 'BULLISH').length || 1);
      const f1Score = 2 * (precision * recall) / (precision + recall);
      
      agents.push({
        agent: agentName,
        accuracy: precision,
        precision,
        recall,
        f1Score,
        confusionMatrix
      });
      
      console.log(`${agentName} Performance:`, {
        accuracy: (precision * 100).toFixed(2) + '%',
        f1Score: (f1Score * 100).toFixed(2)
      });
    }
    
    // 最も性能のエージェントを特定
    const bestAgent = agents.reduce((prev, current) => 
      current.f1Score > prev.f1Score ? current : prev
    );
    
    console.log('Best performing agent:', bestAgent.agent);
    
    expect(bestAgent.f1Score).toBeGreaterThan(0.7); // F1スコア70%以上
    expect(bestAgent.accuracy).toBeGreaterThan(0.6); // 精度60%以上
  });

  describe('エージェントの改善点特定', () => {
    const testMarketData = generateTestData('AAPL', 252);
    
    // ChairmanAgentの改善点分析
    const chairman = getAgentInstance('ChairmanAgent');
    const trainingData = testMarketData.slice(0, 252);
    chairman.train(trainingData);
    
    // テストデータでの予測精度
    const predictions = testMarketData.slice(252).map(data => 
      chairman.analyze(data, 'BULL_TREND')
    );
    
    // 予測の信頼度分布を確認
    const confidenceScores = predictions.map(p => p.confidence || 0);
    const avgConfidence = confidenceScores.reduce((sum, score) => sum + score, 0) / confidenceScores.length;
    
    console.log('ChairmanAgent信頼度分布:', {
      average: (avgConfidence * 100).toFixed(2) + '%',
      min: Math.min(...confidenceScores) * 100,
      max: Math.max(...confidenceScores) * 100
    });
    
    // 信頼度が低い予測の特定
    const lowConfidencePredictions = predictions.filter(p => 
      (p.confidence || 0) < 50
    );
    
    console.log(`低信頼度予測の割合: ${(lowConfidencePredictions.length / predictions.length * 100).toFixed(2)}%`);
    
    // 改善点の特定
    expect(avgConfidence).toBeGreaterThan(60); // 平均信頼度60%以上
    expect(lowConfidencePredictions.length).toBeLessThan(predictions.length * 0.3); // 低信頼度は30%以下に
  });

  describe('エージェントの重み付けとコンセンサス', () => {
    const testMarketData = generateTestData('AAPL', 252);
    
    // 個人エージェントの初期化
    const chairman = getAgentInstance('ChairmanAgent');
    const trendAgent = getAgentState('TrendAgent');
    const reversalAgent = getAgentState('ReversalAgent');
    const volatilityAgent = getAgentState('VolatilityAgent');
    
    // 学習データで初期化
    const trainingData = testMarketData.slice(0, 252);
    chairman.train(trainingData);
    trendAgent.train(trainingData);
    reversalAgent.train(trainingData);
    volatilityAgent.train(trainingData);
    
    // コンセンサスシステムのテスト
    const consensusEngine = new ConsensusEngine();
    
    // 各エージェントの意見を収集
    const agentResults = [
      chairman.analyze(testMarketData[testMarketData.length - 1], 'BULL_TREND'),
      trendAgent.analyze(testMarketData[testMarketData.length - 1], 'BULL_TREND'),
      reversalAgent.analyze(testMarketData[testMarketData.length - 1], 'BEARISH_TREND'),
      volatilityAgent.analyze(testMarketData[testMarketData.length - 1], 'NEUTRAL')
    ];
    
    // コンセンサス計算
    const consensusScore = calculateConsensusScore(agentResults);
    
    expect(consensusScore).toBeGreaterThan(0.5); // コンセンサススコア50%以上
    expect(consensusScore).toBeLessThan(1.0); // スコアは1.0以下に制限
  });

  describe('市場レジーム適応の改善', () => {
    const testMarketData = generateTestData('AAPL', 252);
    
    // 異場データにレジーム情報を追加
    const marketDataWithRegime = testMarketData.map((data, index) => {
      const rsi = calculateRSI(data);
      const macd = calculateMACD(data);
      const adx = calculateADX(data);
      
      let regime: 'BULL_TREND' | 'BEAR_TREND' | 'SIDEWAYS' | 'VOLATILE' | 'SQUEEZE';
      
      // レジーム判定ロジック
      if (adx.adx > 30) {
        if (data.close > data.open && data.close > data.sma20 && data.sma20 > data.sma50) {
          regime = 'BULL_TREND';
        } else if (data.close < data.open && data.close < data.sma20 && data.sma20 < data.sma50) {
          regime = 'BEAR_TREND';
        } else {
          regime = 'SIDEWAYS';
        }
      } else if (Math.abs(rsi - 50) < 10) {
        regime = 'SIDEWAYS';
      } else if (adx.adx < 20 && Math.abs(rsi - 50) > 10) {
        regime = 'VOLATILE';
      } else {
        regime = 'SIDEWAYS';
      }
      
      return { ...data, regime, rsi, macd, adx };
    });
    
    // レジーム適応型エージェント
    const regimeAdaptiveAgent = new RegimeAdaptiveAgent();
    regimeAdaptiveAgent.train(marketDataWithRegime);
    
    // レジーム変化時のテスト
    const regimeChanges = marketDataWithRegime.filter((data, index, array) => 
      index > 0 && data.regime !== array[index - 1].regime
    );
    
    const regimeAdaptationAccuracy = regimeChanges.length > 0 ? 
      regimeAdaptiveAgent.predict(regimeChanges[regimeChanges.length - 1]) : 0;
    
    console.log(`レジーム適応精度: ${(regimeAdaptationAccuracy * 100).toFixed(2)}%`);
    
    expect(regimeAdaptationAccuracy).toBeGreaterThan(0.6); // レジーム適応精度60%以上
  });
});

// エージェントインスタンス取得のヘルパー
function getAgentInstance(agentName: string) {
  switch (agentName) {
    case 'ChairmanAgent':
      return new ChairmanAgent();
    case 'TrendAgent':
      return new TrendAgent();
    case 'ReversalAgent':
      return new ReversalAgent();
    case 'VolatilityAgent':
      return new VolatilityAgent();
    default:
      throw new Error(`Unknown agent: ${agentName}`);
  }
}

// エージェント状態取得のヘルパー
function getAgentState(agentName: string) {
  switch (agentName) {
    case 'TrendAgent':
      return new TrendAgent();
    case 'ReversalAgent':
      return new ReversalAgent();
    case 'VolatilityAgent':
      return new VolatilityAgent();
    default:
      throw new Error(`Unknown agent: ${agentName}`);
  }
}

// コンセンサスエンジン
class ConsensusEngine {
  private weights = {
    'CHAIRMAN': 2.0,
    'VOLATILE': 1.5,
    'TREND': 1.0,
    'REVERSAL': 1.0
  };
  
  calculateConsensusScore(results: any[]): number {
    let totalScore = 0;
    let totalWeight = 0;
    
    results.forEach(result => {
      const weight = this.weights[result.role] || 1.0;
      const score = this.getAgentScore(result);
      totalScore += score * weight;
      totalWeight += weight;
    });
    
    return totalWeight > 0 ? totalScore / totalWeight : 0;
  }
  
  private getAgentScore(result: any): number {
    let direction = 0;
    if (result.signal === 'BUY') direction = 1;
    else if (result.signal === 'SELL') direction = -1;
    return direction * (result.confidence || 0);
  }
}

// レジーム適応型エージェント
class RegimeAdaptiveAgent {
  private regimeHistory: string[] = [];
    
  train(data: StockDataPoint[]): void {
    // 過去1年分のデータで学習
    const trainingData = data.slice(0, 252);
    
    // レジーム履歴を記録
    this.regimeHistory = trainingData.map(d => d.regime || 'SIDEWAYS');
    
    // 基本的な学習
    this.trainBasic(trainingData);
  }
  
  predict(data: StockDataPoint): string {
    const currentRegime = this.regimeHistory[this.regimeHistory.length - 1] || 'SIDEWAYS';
    
    // レジーム変化の検出
    const regimeChanges = this.regimeHistory.slice(-10);
    const recentChanges = regimeChanges.filter((r, i, arr) => r !== arr[i - 1]);
    
    if (recentChanges.length >= 3) {
      // レジームが頻繁に変化している場合、適応型予測
      return this.predictRegimeChange(data, currentRegime);
    }
    
    // 通常の予測
    return this.predictNormal(data, currentRegime);
  }
  
  private predictRegimeChange(data: StockData, currentRegime: string): string {
    // 簡単なレジーム変化予測
    const rsi = calculateRSI(data);
    const macd = calculateMACD(data);
    const adx = calculateADX(data);
    
    if (adx > 30) {
      return 'VOLATILE';
    } else if (adx < 20) {
      return 'SIDEWAYS';
    } else if (data.close > data.open && data.close > data.sma20 && data.sma20 > data.sma50) {
      return 'BULL_TREND';
    } else if (data.close < data.open && data.close < data.sma20 && data.sma20 < data.sma50) {
      return 'BEAR_TREND';
    }
    
    return currentRegime;
  }
  
  private predictNormal(data: StockData, currentRegime: string): string {
    // 既存のレジームを維持
    return currentRegime;
  }
  
  private trainBasic(data: StockDataPoint[]): void {
    // 基本的な学習ロジック
    // 実�本的には既存のロジックを維持
  }
}

// 技術指標準計算
function calculateRSI(data: StockDataPoint): number {
  if (data.length < 14) return 50;
  
  const gains = data.slice(1).map((d, i) => 
    (d.close - data[i].close) / data[i].close
  );
  const losses = gains.filter(g => g < 0);
  
  const avgGain = gains.length > 0 ? gains.reduce((sum, g) => sum + g, 0) : 0;
  const avgLoss = losses.length > 0 ? losses.reduce((sum, l) => sum + l, 0) : 0;
  
  return 100 - (avgLoss / (avgGain || 1));
}

function calculateMACD(data: StockDataPoint[]): any {
  if (data.length < 26) return null;
  
  const closingPrices = data.map(d => d.close);
  const ema12 = data.slice(-12, -1).map(d => d.close);
  const ema26 = data.slice(-26, -13).map(d => d.close);
  
  const macd12 = ema12.reduce((sum, val, i) => sum + val, 0) / 12;
    const macd26 = ema26.reduce((sum, val, i) => sum + val, 0) / 26;
    
  return { macd12, macd26 };
}

function calculateADX(data: StockData[]): any {
  if (data.length < 14) return null;
  
  const highPrices = data.map(d => d.high);
  const lowPrices = data.map(d => d.low);
  
  const avgHigh = highPrices.reduce((sum, val) => sum + val, 0) / highPrices.length;
    const avgLow = lowPrices.reduce((sum, val) => sum + val, 0) / lowPrices.length;
    
  return { avgHigh, avgLow };
}